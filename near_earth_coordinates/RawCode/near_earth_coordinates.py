# -*- coding: utf-8 -*-
"""near_earth_coordinates.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k2ZjACTNfrz3M4qD4A7xy8TJUlfZekC5
"""

import numpy as np
from math import cos,sin,acos,atan2,sqrt,pi
from numpy import cross,dot
from numpy.linalg import norm

def cartesian2keplerian(r,v,mu):
  """
  The function makes the transition of Cartesian coordinates and velocities to Keplerian orbits.

  Cartesian coordinates: Oxy - equatorial plane, x indicates zero latitude and zero longitude.
  Keplerian coordinates were chosen as follows:
  a - apogee
  e - eccentricity
  i - orbital inclination
  Om - longitude of the ascending node
  w - pericenter argument
  nu - true anomaly

  Take output that way: a,e,i,Om,w,nu = cartesian2keplerian(r,v,mu),
  where r and v have dimention 3, and mu - standard gravitational parameter
  """
  tmp1 = [1,2,3]
  tmp = [1,2,3]
  tmp11 = [1.1,2,3]
  tmp2 = np.array([1,2,3])
  tmp21 = np.array([1.1,2,3])
  if (type(r) != type(tmp1)) and (type(r) != type(tmp2)) or (len(r) != 3) or (type(r[0]) != type(tmp1[0])) and (type(r[0]) != type(tmp2[0])) and (type(r[0]) != type(tmp11[0])) and (type(r[0]) != type(tmp21[1])) or (type(r[1]) != type(tmp1[0])) and (type(r[1]) != type(tmp2[1])) and (type(r[1]) != type(tmp11[0])) and (type(r[1]) != type(tmp21[1])) or (type(r[2]) != type(tmp1[0])) and (type(r[2]) != type(tmp2[1])) and (type(r[2]) != type(tmp11[0])) and (type(r[2]) != type(tmp21[1])):
    raise TypeError('r must be list/numpy array of int/float with length 3')
  if (type(v) != type(tmp1)) and (type(v) != type(tmp2)) or (len(v) != 3) or  (type(v[0]) != type(tmp1[0])) and (type(v[0]) != type(tmp2[1])) and (type(v[0]) != type(tmp11[0])) and (type(v[0]) != type(tmp21[1])) or (type(v[1]) != type(tmp1[0])) and (type(v[1]) != type(tmp2[1])) and (type(v[1]) != type(tmp11[0])) and (type(v[1]) != type(tmp21[1])) or  (type(v[2]) != type(tmp1[0])) and (type(v[2]) != type(tmp2[1])) and (type(v[2]) != type(tmp11[0])) and (type(v[2]) != type(tmp21[1])):
    raise TypeError('v must be list/numpy array of int/float with length 3')
  if (type(mu) != type(2.2)) and (type(mu) != type(2)):
    raise TypeError('Gravitational parameter must be int/float')
  if mu <= 0:
    raise ValueError('Gravitational parameter must be positive')
  r = np.array(r)
  v = np.array(v)
  c = cross(r,v)
  f = cross(v,c) - mu*r/norm(r)
  h = sum([i**2 for i in v]) - 2*mu/norm(r)
  if h >= 0:
    raise ValueError('The movement must be finite')
  a = -mu/h 
  e = norm(f)/mu 
  i = acos(np.dot(c,np.array([0,0,1])/norm(c)))
  tmp = cross(np.array([0,0,1]), c)
  if norm(tmp)>0:
    l = tmp/norm(tmp) #ascending node vector
  else:
    l = f/norm(f)
  Om = atan2(dot(l,np.array([0,1,0])),dot(l,np.array([1,0,0])))
  d = cross(c,f)/norm(cross(c,f)) #auxiliary vector
  nu = atan2(dot(r,d),dot(r,f/norm(f)))
  w = atan2(dot(f/norm(f),cross(c/norm(c),l)),dot(f/norm(f),l))
  return a,e,i,Om,w,nu

def keplerian2cartesian(a,e,i,Om,w,nu,mu):
  """
  The function makes the transition of Keplerian orbits to Cartesian coordinates and velocities.

  Cartesian coordinates: Oxy - equatorial plane, x indicates zero latitude and zero longitude.
  Keplerian coordinates were chosen as follows:
  a - apogee
  e - eccentricity
  i - orbital inclination
  Om - longitude of the ascending node
  w - pericenter argument
  nu - true anomaly

  Take output that way: r,v = keplerian2cartesian(a,e,i,Om,w,nu,mu),
  where r and v have dimention 3, and mu - standard gravitational parameter
  """
  tmp1 = np.array([1,2])
  tmp2 = np.array([1.1,2])
  if (type(mu) != type(2.2)) and (type(mu) != type(2)) and (type(mu) != type(tmp1[0]))  and (type(mu) != type(tmp2[0]))     or  (type(a) != type(2.2)) and (type(a) != type(2))  and (type(a) != type(tmp1[0]))  and (type(a) != type(tmp2[0]))     or  (type(e) != type(2.2)) and (type(e) != type(2))  and (type(e) != type(tmp1[0]))  and (type(e) != type(tmp2[0]))      or  (type(i) != type(2.2)) and (type(i) != type(2))  and (type(i) != type(tmp1[0]))  and (type(i) != type(tmp2[0]))       or  (type(Om) != type(2.2)) and (type(Om) != type(2))  and (type(Om) != type(tmp1[0]))  and (type(Om) != type(tmp2[0]))        or  (type(w) != type(2.2)) and (type(w) != type(2))  and (type(w) != type(tmp1[0]))  and (type(w) != type(tmp2[0]))          or   (type(nu) != type(2.2)) and (type(nu) != type(2)) and (type(nu) != type(tmp1[0]))  and (type(nu) != type(tmp2[0])):  
    raise TypeError('Parameters must be int/float')
  if mu <= 0:
    raise ValueError('Gravitational parameter must be positive')
  if a <= 0:
    raise ValueError('Apogee must be positive')
  if e < 0 or e>=1:
    raise ValueError('Eccentricity must belong to the interval [0,1)')
  u = w + nu
  p = a*(1-e**2)
  r = p/(1+e*cos(nu))
  c = sqrt(p*mu)
  A1 = [[cos(-Om), sin(-Om), 0],
        [-sin(-Om), cos(-Om), 0],
        [0,0,1]]
  A2 = [[1,0,0],
        [0, cos(-i), sin(-i)],
        [0, -sin(-i), cos(-i)]]
  A3 = [[cos(-u), sin(-u), 0],
        [-sin(-u), cos(-u), 0],
        [0,0,1]]
  A = np.dot(np.dot(A1,A2),A3)
  R = np.array([r*cos(nu), r*sin(nu), 0])
  dr = c/p*e*sin(nu)
  dv = c/r**2
  V = np.array([dr*cos(nu) - r*dv*sin(nu), dr*sin(nu) + r*dv*cos(nu), 0])
  return dot(A,R.transpose()),dot(A,V.transpose())

atan2(1,-1)

